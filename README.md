# uui

Библиотека для построения графических интерфейсов и работы с железом
на embedded-платформах.

Это petproject. Велосипед — осознанный.

## Обзор

Цели проекта:
- декларативное описание интерфейса и конфигурации железа
- компактная реализация
- никакой динамической памяти
- универсальность для разных экранов и микроконтроллеров
- возможность эмуляции интерфейса на Linux

## Структура проекта

### lib

Основная библиотека.

- `common/` — утилиты: строки, время, кольцевые буферы, списки, таймеры, макросы, dp
- `hw/` — работа с железом
  - `include/` — абстрактные интерфейсы: gpio, spi, i2c, usart, pwm
  - `drivers/` — драйверы устройств (LCD, SD, TCA8418, BQ25896...), зависят только от абстрактных интерфейсов
  - `esp32/` — реализация интерфейсов для ESP32-S3
  - `uc_hw/` — реализация интерфейсов для STM32/GD32
- `graphic/` — графический стек: виджеты, шрифты, формы, ui_tree
- `storage/` — файловая система во флеше с wear leveling
- `specific/` — кнопки, клавиатура, обработчик нажатий
- `cr/` — поддержка корутин
- `emu/` — реализация драйверов для эмуляции на Linux/SDL: LCD, GPIO, RTC, systick

### tests

- аппаратные (`hw/`) — отдельные проекты под ESP32-S3, каждый проверяет конкретный периферийный модуль
- консольные — запускаются на Linux, проверяют логику: строки, хранилище, корутины
- графические — рендеринг ui_tree и виджетов на Linux через эмулятор из `lib/emu/`

## Поддерживаемые платформы

- ESP32-S3
- STM32F1xx
- STM32F0xx
- STM32G0xx
- GD32E230

## Сборка

### ESP32-S3

Каждый тест и демо — отдельный каталог со своим Makefile,
подключающим общий `lib/hw/esp32/build_esp32.mk`.

    make          — собрать
    make flash    — прошить на /dev/ttyACM0
    make clean    — очистить артефакты
    make asm      — дизассемблер (objdump | less)
    make monitor  — открыть serial monitor
    make reset    — сбросить устройство

## Архитектурные принципы

### Нет динамической памяти

Никакого malloc/free. Всё аллоцируется статически — в BSS, стеке
или флеше. Размеры буферов задаются на этапе компиляции.

### Конфиг константный, живёт во флеше

Конфиг описывает всё необходимое для работы сущности и объявляется
как `const`. Компилятор размещает его в `.rodata` (флеш).
Конфиг может содержать указатели на изменяемые данные — сам указатель
константный, данные по нему нет.

```c
const spi_cfg_t spi = {
    .spi = &GPSPI2,
    .gpio_list = &(gpio_list_t){
        .count = 2,
        .pin_list = {
            [SPI_PIN_MOSI] = { .pin = 34, .signal = FSPID_OUT_IDX },
            [SPI_PIN_SCK]  = { .pin = 35, .signal = FSPICLK_OUT_IDX }
        }
    }
};
```

### Контексты выделяются вне драйвера

Изменяемое состояние (контекст) выделяется в пользовательском коде
и передаётся через указатель в конфиге. Драйвер не хранит
глобального состояния.

```c
static usart_ctx_t debug_ctx;

const usart_cfg_t debug_usart = {
    .usart = USART1,
    .ctx   = &debug_ctx,
    ...
};
```

### Одного конфига достаточно

Любая сущность имеет один конфиг, который полностью описывает
всю аппаратную часть — пины, шину, адрес, буферы. Инициализация
принимает только этот конфиг.

### Экономия ресурсов

Память ограничена — это учитывается явно на всех уровнях.
Однородные данные группируются, общее хранится один раз, дублирование исключается.
Каждая сущность необходима и достаточна.

### Библиотеки универсальные

`lib/hw/drivers/` и `lib/graphic/` не зависят от конкретного МК.
Платформозависимый код изолирован в `lib/hw/esp32/` и `lib/hw/uc_hw/`
и реализует одни и те же абстрактные интерфейсы из `lib/hw/include/`.

## Типовые приёмы

### Compound literal для вложенных конфигов

Анонимные объекты прямо внутри конфига — без лишних деклараций:

```c
const spi_dev_cfg_t sx1262 = {
    .spi = &spi_bus,
    .cs_pin = &(gpio_t){
        .pin = { .pin = 36 },
        .cfg = { .mode = GPIO_MODE_OUT }
    }
};
```

### FLEX_WRAP — статическая аллокация структур с гибким массивом

Для структур с `flexible array member` (например `rb_t` с буфером данных)
`FLEX_WRAP` выделяет память в BSS через compound literal анонимной структуры —
без единого malloc:

```c
// rb_t + буфер на 64 байта в BSS
rb_t *rb = FLEX_WRAP(rb_t, 64);

// типизированный буфер на 16 элементов my_event_t:
RB_DESC_CREATE(events, my_event_t, 16);
```

Это даёт гибкость динамической аллокации без единого malloc.
