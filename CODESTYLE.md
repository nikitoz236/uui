# Стиль кода

## Отступы

- 4 пробела, никаких табов

## Фигурные скобки

- Открывающая `{` — на той же строке для `if`/`else`/`for`/`while`, на новой строке для функций
- `{}` обязательны всегда, даже если тело одна строка
- `};` с точкой с запятой только у `enum`/`struct`/`typedef`, у функций и `if`/`for` — просто `}`
- пустое тело цикла: `while (condition) {};` — с `;` после `{}`

```c
void foo(void)
{
    if (x) {
        bar();
    } else {
        baz();
    }
}
```

## Пробелы

- Пробел перед `(` только у `if`/`for`/`while`/`switch`, не у вызовов функций
- Без пробелов внутри скобок: `f(x)`, не `f( x )`
- Без пробела после каста: `(uint8_t)x`
- Без пробела перед `[]`: `arr[i]`
- Указатель на массив — `&arr[0]`, не голое имя `arr`: `func(&buf[0], sizeof(buf))`
- Пробел с обеих сторон звёздочки: `uint8_t * ptr`

```c
void foo(uint8_t * ptr)
{
    uint8_t x = (uint8_t) ptr[0];
    if (x) {
        bar(x);
    }
}
```

## Выравнивание

- Без выравнивания `=` по столбцам в обычном коде
- Все столбцы выравнивания кратны 4 (абсолютная позиция в строке)
- В `enum` значения `=` выравниваются на один столбец **на весь файл** (с учётом уровня вложенности). Столбец — ближайшее кратное 4 после самого длинного имени + 1 пробел:

```c
//                                      col 32
//                                      v
typedef enum {
    SX1262_SF7                  = 0x07,
    SX1262_SF12                 = 0x0C,
} sx1262_sf_t;

typedef enum {
    SX1262_HEADER_EXPLICIT      = 0x00,
    SX1262_HEADER_IMPLICIT      = 0x01,
} sx1262_header_t;
```

- В битовых полях `: N` выравнивается на один столбец **внутри каждой структуры**. Столбец — ближайшее кратное 4 после самого длинного имени + 1 пробел:

```c
//                                          col 36
//                                          v
typedef union {
    uint16_t raw;
    struct {
        uint8_t tx_done            : 1;
        uint8_t preamble_detected  : 1;
        uint8_t timeout            : 1;
    };
} sx1262_reg_irq_t;
```

- Без выравнивания `//` комментариев по столбцам
- В прототипах функций — один пробел между типом и именем, без выравнивания по столбцам:

```c
// плохо
void     foo(void);
unsigned bar(void);

// хорошо
void foo(void);
unsigned bar(void);
```

## include

- Порядок `#include` не менять
- Сначала собственный заголовок, потом зависимости:

```c
#include "xl9555.h"
#include "i2c.h"
#include "buf_endian.h"
```

## Длина строки

- Не ограничена

## Числовые литералы

- Там где тип не важен (сдвиги, маски, индексы) — обычный `int`-литерал без суффиксов и кастов: `1 << pin`
- Суффиксы `u`/`U`/`L` и явные касты не использовать без необходимости

## Флаги и булевы значения

- Для флагов 0/1 в переменных, параметрах и возвращаемых значениях — `unsigned`, не `uint8_t` — `uint8_t` вынуждает компилятор генерировать лишнюю инструкцию `uxtb` при возврате из функции
- Для битовых полей в register union — всегда `uint8_t`, не `unsigned` (см. «Битовые поля в register union»)

## Типы переменных

Основная парадигма: минимум лишних инструкций приведения типов. На стеке переменные выровнены по размеру машинного слова, поэтому `uint8_t`/`uint16_t` в локальных переменных не экономят память, но могут порождать лишние `uxtb`/`uxth`.

- Локальные переменные, параметры функций, возвращаемые значения — `unsigned` (или `int` если знаковость нужна), если разрядность не важна
- `uint8_t`/`uint16_t`/`uint32_t` — только там где разрядность имеет значение:
  - поля структур (layout, компактность)
  - буферы и wire-протоколы (фиксированный формат байт)
  - параметры HAL-функций с конкретным размером (`i2c_transaction` и т.п.)

## Выражения

- Никаких тернарных операторов — только `if`/`else`
- Сложные выражения разбивать на несколько строк с промежуточными переменными
- Никаких compound literal в `return` — всегда создавать переменную нужного типа и возвращать её

```c
// плохо
uint8_t x = (read_reg(addr, REG) >> gpio->pin) & gpio->mask ? 1 : 0;

// хорошо
uint16_t val = read_reg(addr, REG);
uint8_t bit = (val >> gpio->pin) & 1;
```

```c
// плохо — compound literal в return
return (sx1262_reg_irq_t){ .raw = u16_from_be_buf8(&rx[0]) };

// хорошо — переменная с именем типа, потом return
sx1262_reg_irq_t irq = { .raw = u16_from_be_buf8(&rx[0]) };
return irq;
```

## Структуры и инициализаторы

- Пробелы внутри `{}`: `{ .pin = 3 }`, не `{.pin=3}`
- В объявлении структуры каждое поле всегда на отдельной строке — даже для локальных wire-структур

- `typedef struct` без тега если тип не используется рекурсивно
- `__attribute__((packed))` когда нужна компактность битовых полей
- Нулевая инициализация: `uint8_t p[2] = {}`, не `uint8_t p[] = { 0x00, 0x00 }`
- Каждый уровень вложенности — +4 пробела от родителя, закрывающая `}` на отдельной строке на том же уровне что и открывающий элемент
- Листовые (самые глубокие) структуры — в одну строку, внешние уровни — по одному полю на строку:

```c
// хорошо — .gpio и .cfg в одну строку, gpio_t раскрыта
.reset = &(gpio_t){
    .gpio = { .port = GPIO_PORT_B, .pin = 7 },
    .cfg = { .mode = GPIO_MODE_OUTPUT, .speed = GPIO_SPEED_LOW, .type = GPIO_TYPE_PP },
},

// плохо — каждое поле .cfg на отдельной строке (слишком глубоко)
.reset = &(gpio_t){
    .gpio = {
        .port = GPIO_PORT_B,
        .pin = 7,
    },
    .cfg = {
        .mode = GPIO_MODE_OUTPUT,
        .speed = GPIO_SPEED_LOW,
        .type = GPIO_TYPE_PP,
    },
},
```

```c
typedef struct __attribute__((packed)) {
    uint8_t addr_offset : 3;
    uint8_t pin         : 4;
    uint8_t dir         : 1;
    uint8_t polarity    : 1;
} xl9555_gpio_t;
```

## Отладочный вывод (dp)

- Все вызовы `dp`/`dpx`/`dpd`/`dpxd` которые печатают одну логическую строку — в одну строку кода, завершается `dn()` или `dpn()` если последний элемент — строка:

```c
dp("CID MID: "); dpx(cid.mid, 1); dp(" OEM: "); dpxd(cid.oid, 1, 2); dn();
```

## Именование

- `snake_case` везде
- Тип — суффикс `_t`: `xl9555_gpio_t`
- Функции — префикс модуля: `xl9555_gpio_set`, `init_xl9555_gpio`
- Макросы и enum-константы — `UPPER_SNAKE_CASE`
- Статические хелперы внутри `.c` — короткие имена без префикса модуля: `read_reg`, `write_reg`

## Wire-буферы и endianness

- Все SPI/I2C-пейлоады (tx и rx) оформляются как `struct` с именованными полями — не безымянные `uint8_t[]` массивы
- Если в пейлоаде одно поле — не заводить структуру, использовать массив или переменную
- Многобайтные поля (16/32 бит) в wire-структурах — `uint8_t[2]`/`uint8_t[4]`, обращение через `buf_endian.h` (`u16_to_be_buf8`, `u16_from_be_buf8`, `u32_to_be_buf8` и т.д.)
- Регистры чипов, читаемые как битовые маски — `typedef union` с `.raw` и анонимным `struct` с битовыми полями; имя типа с префиксом `_reg_` (например `sx1262_reg_status_t`)

### Битовые поля в register union

Все битовые поля меньше 8 бит — только `uint8_t`, не `unsigned`:

```c
// хорошо
struct {
    uint8_t tx_done : 1;
    uint8_t crc_err : 1;
};

// плохо
struct {
    unsigned tx_done : 1;
    unsigned crc_err : 1;
};
```

Причина: `unsigned` это `unsigned int` — 4 байта на ARM и Xtensa. Компилятор выбирает storage unit по типу битового поля. Если хотя бы одно поле `unsigned`, анонимный `struct` растягивается до 4 байт, и `sizeof(union)` становится 4 вместо ожидаемых 1 или 2. Когда такой union используется как элемент wire-буфера (`reg_irq_t p[4]`), массив оказывается вдвое длиннее — SPI передаёт мусор.

Реальный баг: `sx1262_reg_irq_t` с `uint16_t raw` и `unsigned` битовыми полями давал `sizeof == 4`. Массив `p[4]` был 16 байт вместо 8 — команда `set_irq_mask` отправляла мусор, DIO1 не срабатывал, передатчик зависал навсегда.

Если в битовом поле объявлен `enum { ... } field : 3` (inline enum), компилятор тоже использует `int` как storage unit → те же 4 байта. Решение — `__attribute__((packed))` на анонимном `struct`:

```c
typedef union {
    uint8_t raw;
    struct __attribute__((packed)) {
        uint8_t : 1;
        enum {
            CMD_DATA_AVAILABLE = 2,
            CMD_TIMEOUT        = 3,
        } cmd_status    : 3;
        enum {
            MODE_STBY_RC  = 2,
            MODE_STBY_XOSC = 3,
        } chip_mode     : 3;
        uint8_t : 1;
    };
} reg_status_t;
```

Без `packed` — `sizeof == 4`, с `packed` — `sizeof == 1`, совпадает с `.raw`.
- Все задокументированные поля периферии должны быть описаны в структуре — даже если драйвер их не использует. Неиспользуемые поля не скрывать за безымянными `: N` — давать имя по документации
- Если битовое поле имеет набор именованных значений из документации чипа — описывать `enum { ... }` прямо внутри анонимного `struct` с указанием ширины:

```c
typedef union {
    uint8_t raw;
    struct __attribute__((packed)) {
        uint8_t : 1;
        enum {
            SX1262_CMD_DATA_AVAILABLE = 2,
            SX1262_CMD_TIMEOUT        = 3,
        } cmd_status : 3;
        enum {
            SX1262_MODE_STBY_RC = 2,
            SX1262_MODE_STBY_XOSC = 3,
        } chip_mode : 3;
        uint8_t : 1;
    };
} sx1262_reg_status_t;
```

```c
// хорошо — поля названы, endianness через buf_endian
struct { uint8_t addr[2]; uint8_t val; } p = { .val = val };
u16_to_be_buf8(p.addr, addr);

// плохо — безымянный массив, ручные сдвиги
uint8_t p[] = { (addr >> 8) & 0xFF, addr & 0xFF, val };
```
