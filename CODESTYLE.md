# Стиль кода

## Отступы

- 4 пробела, никаких табов

## Фигурные скобки

- Открывающая `{` — на той же строке для `if`/`else`/`for`/`while`, на новой строке для функций
- `{}` обязательны всегда, даже если тело одна строка
- `};` с точкой с запятой только у `enum`/`struct`/`typedef`, у функций и `if`/`for` — просто `}`
- пустое тело цикла: `while (condition) {};` — с `;` после `{}`

```c
void foo(void)
{
    if (x) {
        bar();
    } else {
        baz();
    }
}
```

## Пробелы

- Пробел перед `(` только у `if`/`for`/`while`/`switch`, не у вызовов функций
- Без пробелов внутри скобок: `f(x)`, не `f( x )`
- Без пробела после каста: `(uint8_t)x`
- Без пробела перед `[]`: `arr[i]`
- Пробел с обеих сторон звёздочки: `uint8_t * ptr`

```c
void foo(uint8_t * ptr)
{
    uint8_t x = (uint8_t) ptr[0];
    if (x) {
        bar(x);
    }
}
```

## Выравнивание

- Без выравнивания `=` по столбцам в обычном коде
- В `enum` значения выравниваются вручную:

```c
enum {
    XL9555_REG_INPUT    = 0,
    XL9555_REG_OUTPUT   = 1,
    XL9555_REG_POLARITY = 2,
    XL9555_REG_CONFIG   = 3,
};
```

- Без выравнивания `//` комментариев по столбцам
- В прототипах функций — один пробел между типом и именем, без выравнивания по столбцам:

```c
// плохо
void     foo(void);
unsigned bar(void);

// хорошо
void foo(void);
unsigned bar(void);
```

## include

- Порядок `#include` не менять
- Сначала собственный заголовок, потом зависимости:

```c
#include "xl9555.h"
#include "i2c.h"
#include "buf_endian.h"
```

## Длина строки

- Не ограничена

## Числовые литералы

- Там где тип не важен (сдвиги, маски, индексы) — обычный `int`-литерал без суффиксов и кастов: `1 << pin`
- Суффиксы `u`/`U`/`L` и явные касты не использовать без необходимости

## Флаги и булевы значения

- Для флагов 0/1 использовать `unsigned`, не `uint8_t` — `uint8_t` вынуждает компилятор генерировать лишнюю инструкцию `uxtb` при возврате из функции

## Типы переменных

Основная парадигма: минимум лишних инструкций приведения типов. На стеке переменные выровнены по размеру машинного слова, поэтому `uint8_t`/`uint16_t` в локальных переменных не экономят память, но могут порождать лишние `uxtb`/`uxth`.

- Локальные переменные, параметры функций, возвращаемые значения — `unsigned` (или `int` если знаковость нужна), если разрядность не важна
- `uint8_t`/`uint16_t`/`uint32_t` — только там где разрядность имеет значение:
  - поля структур (layout, компактность)
  - буферы и wire-протоколы (фиксированный формат байт)
  - параметры HAL-функций с конкретным размером (`i2c_transaction` и т.п.)

## Выражения

- Никаких тернарных операторов — только `if`/`else`
- Сложные выражения разбивать на несколько строк с промежуточными переменными

```c
// плохо
uint8_t x = (read_reg(addr, REG) >> gpio->pin) & gpio->mask ? 1 : 0;

// хорошо
uint16_t val = read_reg(addr, REG);
uint8_t bit = (val >> gpio->pin) & 1;
```

## Структуры и инициализаторы

- Пробелы внутри `{}`: `{ .pin = 3 }`, не `{.pin=3}`
- `typedef struct` без тега если тип не используется рекурсивно
- `__attribute__((packed))` когда нужна компактность битовых полей
- Каждый уровень вложенности — +4 пробела от родителя, закрывающая `}` на отдельной строке на том же уровне что и открывающий элемент
- Листовые (самые глубокие) структуры — в одну строку, внешние уровни — по одному полю на строку:

```c
// хорошо — .gpio и .cfg в одну строку, gpio_t раскрыта
.reset = &(gpio_t){
    .gpio = { .port = GPIO_PORT_B, .pin = 7 },
    .cfg = { .mode = GPIO_MODE_OUTPUT, .speed = GPIO_SPEED_LOW, .type = GPIO_TYPE_PP },
},

// плохо — каждое поле .cfg на отдельной строке (слишком глубоко)
.reset = &(gpio_t){
    .gpio = {
        .port = GPIO_PORT_B,
        .pin = 7,
    },
    .cfg = {
        .mode = GPIO_MODE_OUTPUT,
        .speed = GPIO_SPEED_LOW,
        .type = GPIO_TYPE_PP,
    },
},
```

```c
typedef struct __attribute__((packed)) {
    uint8_t addr_offset : 3;
    uint8_t pin         : 4;
    uint8_t dir         : 1;
    uint8_t polarity    : 1;
} xl9555_gpio_t;
```

## Именование

- `snake_case` везде
- Тип — суффикс `_t`: `xl9555_gpio_t`
- Функции — префикс модуля: `xl9555_gpio_set`, `init_xl9555_gpio`
- Макросы и enum-константы — `UPPER_SNAKE_CASE`
- Статические хелперы внутри `.c` — короткие имена без префикса модуля: `read_reg`, `write_reg`
