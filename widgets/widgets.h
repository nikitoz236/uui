#pragma once
#include "forms.h"

/*
    система позволяет создавать произвольное дерево графических объектов
    каждый объект является виджетом - набором функций реализующем функционал и описывается структурой widget_t
    дерево виджетов описывается отдельной константной структурой ui_node_t, которая по сути описывает конфигурацию
    виджета через указатель widget_cfg, конфигурация может содержать любую необходимую виджету информацию, в том числе
    описание дочерних виджетов, а то и целых отдельных деревьев

    само построение происходит внутри статически выделенной области памяти в виде стека сверху вниз
    каждая запись описывает виджет через структуру ui_ctx_t, которая хранит геометрию виджета и произвольный контекст

    также запись хранит размер всех дочерних записей для возможности удаления ветви дерева, индекс записи соответствует
    порядку описания дочерних виджетов в конфигурации widget_cfg, для того чтобы после удаления понимать порядок записей в стеке

    все есть виджет, начиная от всего экрана, все лайоуты массивы итд являются виджетами и сами определяют, как делать и заполнять
    геометрию дочерними виджетами или элементами графики

    для связи интерфейса с бизнес логикой в описании конфигурации виджета можно использовать указатели на обьекты бизнес логики
    а схемы размещения виджетов могут используя указатель на массив данных подсовывать в контекст располагаемого виджета указатель на
    индексные данные для данного виджета

    логика работы:
        1.  сначала по дереву обходятся все виджеты через функцию calc, которая рассчитывает необходимые размеры геометрии
        2.  далее уже вызывается функция draw, которая, зная размеры рассчитывает положения и рисует виджеты
        3.  обработка событий также происходит проходя по дереву. если данная нода не обрабатывает событие, то оно передается дочерним виджетам
            если событие обработано, то оно обнуляется и дальше передается ноль. однако вызов всех функций process происходит в любом случае для
            обновления интерфейса если это необходимо

    получается что либо каждый виджет в контексте должен содержать хотя бы размер своего контекста, а лучше ноду целиком
    либо всегда придется делать event_заглушку для виджетов которые не обрабатывают события
*/

typedef struct ui_node ui_node_t;

// структура описания динамического элемента в дереве виджетов
typedef struct __attribute__((packed)) {
    form_t f;               // геометрия виджета
    const ui_node_t * node; // ссылка на описание данного элемента в дереве
    uint8_t idx;            // индекс данного виджета в описании родительского виджета
    uint8_t child_offset;   // смещение в стеке до первого дочернего виджета, заполняется в calc_node из ctx_len
    uint16_t size;          // размер контекста данного виджета в стеке включая всю дочернюю ветвь
    uint8_t ctx[];          // произвольный контекст данного виджета включая все дочерние виджеты
} ui_ctx_t;

// структура виджета для использования его в описании дерева виджетов
typedef struct __attribute__((packed)) {

    // функция расчета размера виджета и размера контекста
    // рассчитывает все вложенные виджеты и возвращает размер контекста всех вложенных виджетов
    // ui_ctx_t * node_ctx  // указатель на место в динамическом стеке для размещения контекста
    unsigned (*calc)(ui_ctx_t * node_ctx);

    // функция отрисовки виджета
    // ui_ctx_t * node_ctx  // указатель на контекст виджета
    void (*draw)(ui_ctx_t * node_ctx);

    // функция обработки событий, и может быть обновления интерфейса
    // ui_ctx_t * node_ctx  // указатель на контекст виджета
    // unsigned event       // событие
    unsigned (*process)(ui_ctx_t * node_ctx, unsigned event);

    uint8_t ctx_len;        // размер контекста только данного виджета
                            // позволяет определить где начинается первый дочерний виджет

    uint8_t stretched;      // возможно ли менять данному виджету size перед вызовом draw
} widget_t;

struct ui_node {            // элемент описания дерева виджетов
    widget_t * widget;      // указатель на виджет
    void * widget_cfg;      // конфигурация виджета (может включать описание дочерних виджетов)
};

// считает размер прямоугольника виджета и размер контекста, заполняет индекс
// возвращает размер всего своего контекста с учетом ui_ctx_t и вложенных виджетов
// метод calc каждого виджета должен создавать дочерние виджеты через вызов calc_node для каждого
static inline unsigned calc_node(const ui_node_t * node, ui_ctx_t * node_ctx, unsigned idx) {
    node_ctx->idx = idx;
    node_ctx->node = node;
    node_ctx->child_offset = node->widget->ctx_len;
    printf("calc node ctx size: %d ctx_ptr: %p\n", node_ctx->child_offset, node_ctx);
    node_ctx->size = sizeof(ui_ctx_t) + node_ctx->child_offset + node->widget->calc(node_ctx);
    return node_ctx->size;
}

// рисует виджет
static inline void draw_node(ui_ctx_t * node_ctx)
{
    node_ctx->node->widget->draw(node_ctx);
}

// рекурсивно проходит все дерево и вызывает все методы process, если они есть
void process_node(ui_ctx_t * ctx, unsigned event);

// вычисляет указатель на контекст следующего элемента в стеке на том же уровне вложенности
static inline ui_ctx_t * next_child(ui_ctx_t * node_ctx)
{
    return (ui_ctx_t *)((void *)node_ctx + node_ctx->size);
}

// вычисляет указатель на первый дочерний элемент в стеке
static inline ui_ctx_t * first_child(ui_ctx_t * node_ctx)
{
    return (ui_ctx_t *)(node_ctx->ctx + node_ctx->child_offset);
}

// вычисляет размер контекста всех дочерних элементов
static inline unsigned childs_ctx_size(ui_ctx_t * node_ctx)
{
    return node_ctx->size - sizeof(ui_ctx_t) - node_ctx->child_offset;
}
