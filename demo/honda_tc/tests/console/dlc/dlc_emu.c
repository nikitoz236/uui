#include <stdio.h>
#include <stdint.h>
#include "mstimer.h"
#include "str_utils.h"
#include "honda_dlc_units.h"
#include "dlc_frame.h"

#define OBD_SPEED_KMH			123
#define OBD_RPM					4567


static unsigned emu_engine_state = 0;
static unsigned data_requested = 0;

void emu_engine_ctrl(unsigned state)
{
    emu_engine_state = state;
}

static const uint8_t * honda_units_map[] = {
    [HONDA_UNIT_ECU] = (uint8_t []){
        (OBD_RPM / 64),						// 0x00		rpm * 4 high byte
        ((OBD_RPM % 64) * 4),				// 0x01		rpm * 4 low byte
        OBD_SPEED_KMH,						// 0x02		speed km/h
                          0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0xA1, 0x00, 0x00, 0x01,
        0x29, 0x6C, 0x30, 0x00, 0x19, 0x13, 0x00, 0x93, 0x84, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
        0x83, 0x00, 0x80, 0x00, 0x02, 0x74, 0x54, 0x00, 0x17, 0x61, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x2D, 0x37, 0x00, 0x2D, 0x07, 0x2D, 0x19, 0x19, 0x19, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0xB8, 0x10, 0x96, 0x0B, 0x10, 0x10, 0x00, 0x07, 0x00,
        0xF8, 0x00, 0xF8, 0x00, 0xF0, 0x00, 0xF8, 0xF8, 0xFC, 0xF0, 0x00, 0xF8, 0xF8, 0x00, 0x00, 0x80,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x61, 0x02, 0x00, 0x49, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    },
    [HONDA_UNIT_ABS] = (uint8_t []){
        0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF4,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xF8, 0xFF, 0xB5, 0x00, 0x00, 0x00, 0x00,
        0x18, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x63, 0x5D, 0x5D, 0x02, 0x01, 0x02, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x4C,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0xCA, 0xFE,
        0x03, 0x0D, 0x02, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    },
    [HONDA_UNIT_SRS] = (uint8_t []){
        0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x10, 0x00, 0x00, 0x03, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x09, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x04, 0x8F, 0x8F, 0x8F, 0x8F, 0x95, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x0A, 0x00, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
};

static mstimer_t timeout;

void kline_start_transaction(uint8_t * data, unsigned len, uint8_t * response, unsigned resp_len)
{
    kline_request_t * req = (kline_request_t *)data;
    uint8_t * resp = &response[sizeof(kline_request_t)];

    if (req->frame_len != sizeof(kline_request_t)) {
        printf("        DLC EMU ERROR. frame_len != 5\n");
        return;
    }

    if (calc_cs(data, sizeof(kline_request_t)) != 0) {
        printf("        DLC EMU ERROR. wrong req cs\n");
        return;
    }

    if (resp_len != (sizeof(kline_request_t) + req->len + 3)) {
        printf("        DLC EMU ERROR. wrong request len or resp_len\n");
        return;
    }

    honda_unit_t unit;
    if (honda_dlc_unit_from_address(req->cmd, &unit) == 0) {
        printf("        DLC EMU ERROR. unknown cmd\n");
        return;
    }

    if ((req->offset + req->len) > honda_dlc_unit_len(unit)) {
        printf("        DLC EMU ERROR. out of read memory\n");
        return;
    }

    const uint8_t * map = honda_units_map[unit];

    if (emu_engine_state) {
        data_requested = 1;
        resp[0] = 0;
        resp[1] = req->len + 3;
        str_cp(&resp[2], &map[req->offset], req->len);
        resp[req->len + 2] = calc_cs(resp, req->len + 2);
        mstimer_start_timeout(&timeout, 200);
    }
}

unsigned kline_is_resp_available(void)
{
    if (emu_engine_state && data_requested) {
        if (mstimer_is_over(&timeout)) {
            return 1;
        }
    }
    return 0;
}
