#include <stdint.h>
#include "mstimer.h"
#include "str_utils.h"
#include "honda_units.h"
#include <stdio.h>

#define OBD_SPEED_KMH			123
#define OBD_RPM					4567


static unsigned emu_engine_state = 0;
static unsigned data_requested = 0;

void emu_engine_ctrl(unsigned state)
{
    emu_engine_state = state;
}

typedef struct {
    unsigned len;
    uint8_t * data;
    uint8_t cmd;
} mem_map_t;

static const mem_map_t honda_units_map[] = {
    [HONDA_UNIT_ECU] = { .cmd = 0x20, .len = 0x100, .data = (uint8_t []){
        (OBD_RPM / 64),						// 0x00		rpm * 4 high byte
        ((OBD_RPM % 64) * 4),				// 0x01		rpm * 4 low byte
        OBD_SPEED_KMH,						// 0x02		speed km/h
                        0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0xA1, 0x00, 0x00, 0x01,
        0x29, 0x6C, 0x30, 0x00, 0x19, 0x13, 0x00, 0x93, 0x84, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
        0x83, 0x00, 0x80, 0x00, 0x02, 0x74, 0x54, 0x00, 0x17, 0x61, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x2D, 0x37, 0x00, 0x2D, 0x07, 0x2D, 0x19, 0x19, 0x19, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0xB8, 0x10, 0x96, 0x0B, 0x10, 0x10, 0x00, 0x07, 0x00,
        0xF8, 0x00, 0xF8, 0x00, 0xF0, 0x00, 0xF8, 0xF8, 0xFC, 0xF0, 0x00, 0xF8, 0xF8, 0x00, 0x00, 0x80,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x61, 0x02, 0x00, 0x49, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    } },
    [HONDA_UNIT_ABS] = { .cmd = 0xA0, .len = 0x80, .data = (uint8_t []){
        0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF4,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xF8, 0xFF, 0xB5, 0x00, 0x00, 0x00, 0x00,
        0x18, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x63, 0x5D, 0x5D, 0x02, 0x01, 0x02, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x4C,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0xCA, 0xFE,
        0x03, 0x0D, 0x02, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    } },
    [HONDA_UNIT_SRS] = { .cmd = 0x60, .len = 0x80, .data = (uint8_t []){
        0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x10, 0x00, 0x00, 0x03, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x09, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x04, 0x8F, 0x8F, 0x8F, 0x8F, 0x95, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x0A, 0x00, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    } },
};

static mstimer_t timeout;

static uint8_t calc_cs(uint8_t * data, unsigned len)
{
    uint8_t cs = 0;
    while (len--) {
        cs -= *data++;
    }
    return cs;
}

void kline_start_transaction(uint8_t * data, unsigned len, uint8_t * response, unsigned resp_len)
{
    typedef struct {
        uint8_t cmd;
        uint8_t frame_len;
        uint8_t offset;
        uint8_t len;
        uint8_t cs;
    } kline_request_t;

    kline_request_t * req = (kline_request_t *)data;
    if (req->frame_len != 5) {
        printf("        DLC EMU ERROR. frame_len != 5\n");
        return;
    }
    if (calc_cs(data, 4) != req->cs) {
        printf("        DLC EMU ERROR. wrong req cs\n");
        return;
    }
    const mem_map_t * map = 0;
    for (unsigned i = 0; i < HONDA_UNIT_COUNT; i++) {
        if (honda_units_map[i].cmd == req->cmd) {
            map = &honda_units_map[i];
            break;
        }
    }
    if (map == 0) {
        printf("        DLC EMU ERROR. unknown cmd\n");
        return;
    }
    if ((req->offset + req->len) > map->len) {
        printf("        DLC EMU ERROR. out of read memory\n");
        return;
    }
    if (resp_len != (req->len + 3)) {
        printf("        DLC EMU ERROR. wrong request len or resp_len\n");
        return;
    }
    if (emu_engine_state) {
        data_requested = 1;
        response[0] = 0;
        response[1] = req->len + 3;
        str_cp(&response[2], &map->data[req->offset], req->len);
        response[req->len + 2] = calc_cs(response, req->len + 2);
        mstimer_start_timeout(&timeout, 100);
    }
}

unsigned kline_is_resp_available(void)
{
    if (emu_engine_state && data_requested) {
        if (mstimer_is_over(&timeout)) {
            return 1;
        }
    }
    return 0;
}
